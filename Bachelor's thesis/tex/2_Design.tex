%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Authentication %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Authentication}
\subsection{OAuth 2.0}
OAuth 2.0 is the industry-standard protocol for authorization. OAuth 2.0 supersedes the work done on the original OAuth
protocol created in 2006. OAuth 2.0 focuses on client developer simplicity while providing specific authorization flows
for web applications, desktop applications, mobile phones, and living room devices. \cite{oauth}

For server to be able to get list of friends and other information about user, mobile application needs to recieve
token from facebook with appropriate prmissions and send it to the server. Token is a line generated by facebook and
by which facebook provides access to certain data of certain user.



\newcommand{\ritem}[1]{
    \item \textbf{#1} \par
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Server API %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Server API}

\subsection{REST}
Server API will be built on the basis of \ac{REST}. \ac{REST} is the architectural solution for the transfer of
structural data between server and client \cite{rest}.
API is considered RESTful if it follows certain rules \cite{whatisrest}:

\begin{itemize}

\ritem{Client-Server}
Client-Server defines a clear separation between a service and its consumers. Service (in this case server) offers one
or more capabilities and listens for requests on these capabilities. A consumer (in this case mobile client) invokes a
capability by sending the corresponding request message, and the service either rejects the request or performs
the requested task before sending a response message back to the consumer.

\ritem{Stateless}
Statelessness ensures that each service consumer request can be treated independently by the service. The communication
between service consumer (client) and service (server) must be stateless between requests. This means that each request
from a service consumer should contain all the necessary information for the service to understand the meaning of
the request, and all session state data should then be returned to the service consumer at the end of each request.

\ritem{Cache}
Responses may be cached by the consumer to avoid resubmitting the same requests to the service. Response messages  are
explicitly labeled as cacheable or non-cacheable. This way, the service and/or the consumer can cache the response for
reuse in later requests.

\ritem{Uniform Interface}
All services and service consumers within a REST-compliant architecture must share a single, overarching technical
interface. As the primary constraint that distinguishes REST from other architecture types, Interface is generally
applied using the methods and media types provided by HTTP.

\ritem{Layered System}
A REST-based solution can be comprised of multiple architectural layers, and no one layer can ``see past'' the next.
Layers can be added, removed, modified, or reordered in response to how the solution needs to evolve.

\end{itemize}

There is also an optional constraint \textbf{Code-On-Demand}. This constraint states that client application can be
extended if they are allowed to download and execute scripts or plug-ins that support the media type provided by
the server. Adherence to this constraint is therefore determined by client rather than the API \cite{rest}.


\subsection{URL scheme}



\subsection{Apiary}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Chosen technologies %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chosen technologies}
\smplimage{technology_stack}{png}
As I mentioned before, the choice of used technology was not up to me so in this section I will not describe why
certain technologies were chosen, but will describe their advantages (alternatively disadvantages) for this project.


\subsection{Python}
Python is a base of the server. It was chosen as a primary programming language because it was designed to be simple
and highly readable which is very important for large-scale projects. Its syntax and standard library simplify and
speed up a development.

\subsection{Django}
Django is an open source web framework for python. It provides a high level abstraction of common web development
patterns. It follows \ac{MVC} design pattern. Django uses \ac{MVC} to separate model as a data and a business logic of
the application, view as a representation of the information for the user, in this case, the client side of the
application and controller as an interface of the application, in this case, set of URLs to communicate with
front-end \cite{django}.

\subsection{Django REST}
Django REST framework is an open source project built on Django framework. It contains needed tools for implementation
of \ac{REST}ful \ac{API}.

\subsection{PostgreSQL}
On initial stage of the development, SQLite will be used as a \ac{DBMS}, because it does not require a standalone
database server and is simple to set up. The database will be changed and migrated to PostgreSQL later.

PostgreSQL is powerful, open source relational \ac{DBMS}. It has advanced features such as full
atomicity, consistency, isolation, durability \cite{postgres}. Django framework provides great \ac{API} for working
with PostgreSQL databases.

\subsection{nginx}
nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server,
originally written by Igor Sysoev \cite{nginx}. According to Netcraft \cite{netcraft}, nginx served or proxied 28.50\%
busiest sites in March 2017.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Class model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Class model}
\image[1.2]{account_models}{pdf}{Account models}
\image[1.2]{donations_models}{pdf}{Donations models}
\image[1.2]{friendship_models}{pdf}{Friendship models}
\image[1.2]{wishes_models}{pdf}{Wishes models}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Database model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Database model}

