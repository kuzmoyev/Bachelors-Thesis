%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Authentication %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Authentication}
As was mentioned earlier in this thesis, authentication of the~user will be conducted through his Facebook account.
Facebook provides the~interface for user authentication in third-party applications. This interface uses OAuth 2.0 protocol.

\subsection{OAuth 2.0}
\definition{OAuth 2.0} is the~industry-standard protocol for authorization. OAuth 2.0 supersedes the~work done on
the original OAuth protocol created in 2006. OAuth 2.0 focuses on client developer simplicity while providing specific
autho\-rization flows for web applications, desktop applications, mobile phones, and living room devices \cite{oauth}.

For the~server to be able to get a~list of friends and other information about the~user, the~mobile application needs
to receive a~token from Facebook with appropriate permissions and send it to the~server. \definition{Token} is a~line
generated by Facebook and by which Facebook provides access to specific data of the~certain user.

Diagram \ref{fig:authentication_activity} shows mechanism of successful authentication via user's Facebook account.

\image[1.1]{authentication_activity}{pdf}{Authentication activity diagram}

\newcommand{\ritem}[1]{
    \item \textbf{#1} \par
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Server API %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{REST API}

Server API will be built on the~basis of \ac{REST}. \definition{\ac{REST}} is the~architectural solution for
the~transfer of structural data between server and client \cite{rest}. API is considered RESTful if it follows certain
rules \cite{whatisrest}:

\begin{itemize}

\ritem{Client-Server}
Client-Server defines a~clear separation between a~service and its consumers. Service (in this case server) offers one
or more capabilities and listens for requests on these capabilities. A~consumer (in this case mobile client) invokes
a~capability by sending the~corresponding request message, and the~service either rejects the~request or performs
the~requested task before sending a~response message back to the~consumer.

\ritem{Stateless}
Statelessness ensures that each service consumer request can be treated independently by the~service. The~communication
between service consumer (client) and service (server) must be stateless between requests. This means that each request
from a~service consumer should contain all the~necessary information for the~service to understand the~meaning of
the~request, and all session state data should then be returned to the~service consumer at the~end of each request.

\ritem{Cache}
Responses may be cached by the~consumer to avoid resubmitting the~same requests to the~service. Response messages are
explicitly labeled as cacheable or non-cacheable. This way, the~service and the~consumer can cache the~response for
reuse in later requests.

\ritem{Uniform Interface}
All services and service consumers within a~REST-compliant architecture must share a~single, overarching technical
interface. As the~primary constraint that distinguishes REST from other architecture types, Interface is generally
applied using the~methods and media types provided by HTTP.

\ritem{Layered System}
A REST-based solution can be comprised of multiple architectural layers, and no one layer can ``see past'' the~next.
Layers can be added, removed, modified, or reordered in response to how the~solution needs to evolve.

\end{itemize}

There is also an optional constraint \textbf{Code-On-Demand}. This constraint states that client application can be
extended if they are allowed to download and execute scripts or plug-ins that support the~media type provided by
the~server. Adherence to this constraint is therefore determined by the~client rather than the~API \cite{rest}.
\pagebreak

\subsection{Apiary}
The apiary service will be used for the~server API documentation. \definition{Apiary} is a~powerful API design stack
\cite{apiary}. The~Blueprint API is used to describe the~structure of the~APIs in the~apiary.
\definition{API Blueprint} is a~powerful high-level API description language for web APIs \cite{apiblueprint}.

The following screenshot shows an example of the~documented \ac{API} end\-point, specifically GET request on receiving
comments list of the~specified wish.

\image[1.3]{apiary}{png}{Apiary documentation}
\pagebreak

Documentation of every endpoint contains \ac{URL}, mandatory \ac{URL} parameters (filled circle), optional \ac{URL}
parameters (hollow circle), request headers and body format if required, response headers and body format.

The corresponding Blueprint to the~documentation on the~screenshot looks like this:

\begin{lstlisting}[language=]
## Comments to the wish [/wishes/{wish_id}/comments/{?page,page_size}]

### GET [GET]

+ Parameters
    + wish_id: `1` (required, number)
    + page: `1` (optional, number) - page number
        + Default: `1`
    + page_size: `20` (optional, number) - objects count on apage
        + Default: `20`

+ Request (application/json)
    + Headers

            Authorization: Token In_APP_Token

+ Response 200 (application/json)
    + Attributes
        + count: 2 (number) - total number of results
        + next (string, optional, nullable) - next page url
        + previous (string, optional, nullable) - previous page url
        + results (array)
            + (object)
                + id: 1 (number)
                + author: 1 (number)
                + wish: 1 (number)
                + text: `Me too`
                + date_created: `2017-02-10T15:46:33.854478Z`
            + (object)
                + id: 2 (number)
                + author: 3 (number)
                + wish: 1 (number)
                + text: `But why?`
                + date_created: `2016-12-22T15:46:33.854478Z`
\end{lstlisting}

API Blueprint detailed documentation can be found on the~official API Blueprint website \cite{apiblueprint}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Chosen technologies %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chosen technologies}
\smplimage{technology_stack}{png}

As I mentioned before, the~choice of used technology was not up to me so in this section I will not describe why certain
technologies were chosen, but their advantages (alternatively disadvantages) for this project.


\subsection{Python}
\definition{Python} is a~base of the~server. It was chosen as a~primary programming language because it was designed to
be simple and highly readable, which is crucial for large-scale projects. Its syntax and standard library simplify and
speed up development.

\subsection{Django}
\definition{Django} is an open source web framework for Python. It provides a~high-level abstraction of common web
development patterns. Django framework follows \ac{MVC} design pattern. It uses \ac{MVC} to separate model as a~data and
a~business logic of the~application, view as a~representation of the~information for the~user, in this case, the~client
side of the~application and controller as an interface of the~application, in this case, set of \ac{URL}s to communicate
with front-end \cite{django}.

\subsection{Django REST}
\definition{Django REST framework} is an open source project built on Django framework. It contains needed tools for
implementation of the \ac{REST}ful \ac{API} such as serializers, pagination, permissions, etc.

\subsection{PostgreSQL and SQLite}
On initial stage of the~development, SQLite will be used as a~\ac{DBMS}, because it does not require a~standalone
database server and is simple to set up. The~database will be changed and migrated to PostgreSQL later.

\definition{PostgreSQL} is powerful, open source relational \ac{DBMS}. It has advanced features such as full atomicity,
consistency, isolation, durability \cite{postgres}. Django framework provides great \ac{API} for working with PostgreSQL
databases.

\subsection{Nginx}
\definition{Nginx} [engine x] is an \ac{HTTP} and reverse proxy server, a~mail proxy server, and a~generic
\acs{TCP}\footnote{\ac{TCP}}/\acs{UDP}\footnote{\ac{UDP}} proxy server, originally written by Igor Sysoev \cite{nginx}.
According to Netcraft \cite{netcraft}, nginx served or proxied 28.50\% busiest sites in March 2017.


\newcommand{\dbpart}[1]{
\item \textbf{#1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Database model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Database model}
One of the~primary parts of the~web server is the~database. A~database design, the~data model, is created before
the~implementation of the~physical database model.

A data model is a~combination of three components \cite{dbmodel}:

\begin{itemize}
\dbpart{The structural part}: a~collection of data structures (or entity types, or object types) which define the~set of
allowable databases.
\dbpart{The integrity part}: a~collection of general integrity constraints, which specify the~set of consistent
databases or the~set of allowable changes to a~database.
\dbpart{The manipulative part}: a~collection of operators or inference rules, which can be applied to an allowable
database in any required combination to query and update parts of the~database.
\end{itemize}

Thus, the~structure of the~ElateMe database was defined and documented. The~full database model is in the~attachment
\ref{ch:db_model}. It is not included in the~text of this thesis because of its large volume. The~documentation is
divided into logical parts containing the~corresponding database tables, their columns, and connections. Diagrams
include the~following connections:

\smplimage{db_model_connections}{pdf}

This documentation, however, is not an accurate representation of \m{the~physical} database, since Django models are
used to work with the~database, which themselves create tables and connections between them.
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Class model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Class model}
Class model of the~project was built based on Django project structure. Most of the~classes extend Django classes
following certain rules and format. Therefore I will describe only parts that don't depend on Django structure.
A~complete model of classes can be found in the~electronic attachments.

\subsection{Authentication}
As was said before, in frameworks of this work user authentication will be conducted through his Facebook account. But
in the~future, other social networks and authorization methods may be added. Since most of the~social networks support
OAuth 2.0 \cite{oauth}, this allows to make a~universal interface for user authorization, that will process user
authentication via a~social network using token provided by the~client (mobile or web application).

Thus, as shown in the~diagram \ref{fig:social_integration_class_diagram}, classes that extend \class{AbstractSocialAPI}
will provide an interface for token processing. \class{AbstractSocialAPI} defines method \method{process} that receives
token from the~client, requests information about the~user from the~corresponding social network, decides if the~user is
already registered in the~application, registers him (adds to the~database) if necessary, and authorizes the~user in
the~application. Information about user is obtained using abstract methods like \method{request\_data},
\method{get\_social\_id}, \method{get\_friends}, etc.

\image[1.2]{social_integration_class_diagram}{pdf}{Social integration class model}


\subsection{Payments}
Payment information will be stored in the~models that inherit the~\class{Payment} model. Currently, these classes are
\class{FIOBankaPayment} and \class{BitcoinPayment}. They store information for conducting and refunding payments needed
for inter\-faces of FIO-banka and Bitcoins respectively. Payment processing will be performed by \class{PaymentsHandler}s.
They provide interfaces for the~handling of donations, refunds, and payments for the~completed wishes. For each
\class{Payment} model there will be a~corresponding \class{PaymentsHandler}. Which means if a~new payment system
arrives, it will be enough to override the~\class{Payments} class with the~necessary information and implement
the~\class{PaymentsHandler} interface for this particular system.

\image[1.3]{payments_class_diagram}{pdf}{Payments class model}


\subsection{Push notifications}
As shown in the~diagram \ref{fig:push_notifications_class_diagram}, the~\class{EventHandler} class will be responsible
for processing of events which require user notification. This class uses interface of
\class{AbstractNotificationService} for sending of push notifications to the~correspon\-ding \ac{OSPNS}s. Since the~user
can have several devices with the~installed application, there may be situations when one notification will be sent to
several tokens and different \ac{OSPNS}s. Classes that extend \class{AbstractNotificationService} and implement method
\method{notify} will be responsible for sending push notifications to the~specific \ac{OSPNS}.

\image[1.3]{push_notifications_class_diagram}{pdf}{Push notification class model}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Deployment model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Deployment model}
ElateMe implies an enterprise system. That means that its server application needs to be able to cope with a~large
number of simultaneous requests, has to be scalable, secure and reliable.

Nginx will be used as a~reverse proxy server. \definition{Reverse proxy server} is a~type of proxy server that typically
sits behind the~firewall in a~private network and directs client requests to the~appropriate backend server. Using of
such proxy server makes backend application run faster, reduces downtime, consumes less server resources, and improves
security \cite{nginxdeploy}. Nginx will also be used as a~load balancer for multiple application server instances.
\definition{Load balancing} means distributing client requests across a~group of servers in a~manner that maximizes
speed and capacity utilization while ensuring no one server is overloaded, which can degrade performance. If some server
goes down, the~load balancer redirects traffic to the~remaining online servers~\cite{reverseproxy}.

Design of the~ElateMe deplyment model is presented on the~diagram \ref{fig:deployment_model}.
\image[1.3]{deployment_model}{pdf}{Deployment model}

As seen in the~diagram, backend application and database will be running on separate servers. Pros of such approach are

\begin{itemize}
    \item Application and database don't use the~same server resources (CPU, Memory, I/O, etc.)
    \item It allows vertical scaling, by adding more resources to whichever server needs increased capacity.
    \item It increases security by removing the~database from the~\ac{DMZ}\footnote{\ac{DMZ} is a host or small network
that is a neutral zone between a local network and the Internet.}.
\end{itemize}

Nginx in this model is used as a~load balancer which improves performance and reliability by distributing the~workload
across multiple Django application instances. It also allows horizontal scaling, i.e. environment capacity can be scaled
by adding more servers to it.

Currently, the~server is deployed on the~\ac{VPS} with the~database and Django application on the~same machine for
testing purposes.
